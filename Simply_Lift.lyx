#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Simply Lift
\end_layout

\begin_layout Author
David Pollak
\end_layout

\begin_layout Date
11/27/2010
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Part
The Lift Web Framework
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
The Lift Web Framework provides web application developers tools to make
 writing security, interacting, scalable web applications easier than with
 any other web framework.
 After reading Part I of this book, you should understand Lift's core concepts
 and be able to write Lift applications.
 But with anything, practice is important.
 I have been writing Lift and Scala for 4 years, and even I learn new things
 about the language and the framework on a weekly basis.
 Please consider Lift an path and an exploration, rather than an end point.
\end_layout

\begin_layout Standard
Lift is built on top of the 
\begin_inset CommandInset href
LatexCommand href
name "Scala"
target "http://scala-lang.org"

\end_inset

 programming language.
 Scala runs on the 
\begin_inset CommandInset href
LatexCommand href
name "Java Virtual Machine"
target "http://www.oracle.com/technetwork/java/index.html"

\end_inset

.
 Lift applications are typically packaged as 
\begin_inset CommandInset href
LatexCommand href
name "WAR"
target "http://en.wikipedia.org/wiki/WAR_(Sun_file_format)"

\end_inset

 files and run as a 
\begin_inset CommandInset href
LatexCommand href
name "J/EE Servlets"
target "http://www.oracle.com/technetwork/java/index-jsp-135475.html"

\end_inset

 or Servlet Filters.
 This book will provide you with the core concepts you need to successfully
 write Lift web applications.
 The book assumes knowledge of Servlets and Servlet containers, the Scala
 Language (Chapters 1-6 of 
\shape italic

\begin_inset CommandInset href
LatexCommand href
name "Beginning Scala"
target "http://apress.com/book/view/9781430219897"

\end_inset


\shape default
 gives you a good grounding in the language), build tools, program editors,
 web development including HTML and JavaScript, etc.
 Further, this book will not explore persistence.
 Lift has additional modules for persisting to relational and non-relational
 data stores.
 Lift doesn't distinguish as to how an object is materialized into the address
 space...
 Lift can treat any object any old way you want.
 There are many resources (including 
\begin_inset CommandInset href
LatexCommand href
name "Exploring Lift"
target "http://exploring.liftweb.net/"

\end_inset

) that cover ways to persist data from a JVM.
\end_layout

\begin_layout Standard
Lift is different from most web frameworks and it's likely that Lift's differenc
es will present a challenge and a friction if you are familiar with the
 MVC school of web frameworks
\begin_inset Foot
status open

\begin_layout Plain Layout
This includes Ruby on Rails, Struts, Java Server Faces, Django, TurboGears,
 etc.
\end_layout

\end_inset

.
 But Lift is different and Lift's differences give you more power to create
 interactive applications.
 Lift's differences lead to more concise web applications.
 Lift's differences result in more secure and scalable applications.
 Lift's differences let you be more productive and make maintaining applications
 easier for the future you or whoever is writing your applications.
 Please relax and work to understand Lift's differences...
 and see how you can make best use of Lift's features to build your web
 applications.
\end_layout

\begin_layout Standard
Lift creates abstractions that allow easier expression of business logic
 and then maps those abstractions to HTTP and HTML.
 This approach differs from traditional web frameworks which build abstractions
 on top of HTTP and HTML and require the developer to bridge between common
 business logic patterns and the underlying protocol.
 The difference means that you spend more time thinking about your application
 and less time thinking about the plumbing.
\end_layout

\begin_layout Standard
I'm a 
\begin_inset Quotes eld
\end_inset

roll up your sleaves and get your hands dirty with code
\begin_inset Quotes erd
\end_inset

 kinda guy...
 so let's build a simple Chat application in Lift.
 This application will allow us to demonstrate some of Lift's core features
 as well as giving a 
\begin_inset Quotes eld
\end_inset

smack in the face
\begin_inset Quotes erd
\end_inset

 demonstration of how Lift is different.
\end_layout

\begin_layout Chapter
The ubiquitous Chat app
\end_layout

\begin_layout Standard
Writing a multi-user chat application in Lift is super-simple and illustrates
 many of Lift's core concepts.
\end_layout

\begin_layout Section
The View
\end_layout

\begin_layout Standard
When writing a Lift app, it's often best to start off with the user interface...
 build what the user will see and then add behavior to the HTML page.
 So, let's look at the Lift template that will make up our chat application.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "chat/src/main/webapp/index.html"
lstparams "caption={index.html}"

\end_inset


\end_layout

\begin_layout Standard
It's a valid HTML page, but there are some hinky looking class attributes.
 The first one is 
\family typewriter
<body class="lift:content_id=main">
\family default
.
 The class in this case says 
\begin_inset Quotes eld
\end_inset

the actual page content is contained by the element with id='main'.
\begin_inset Quotes erd
\end_inset

 This allows you to have valid HTML pages for each of your templates, but
 dynamically add 
\begin_inset Quotes eld
\end_inset

chrome
\begin_inset Quotes erd
\end_inset

 around the content based on one or more chrome templates.
\end_layout

\begin_layout Standard
Let's look at the 
\family typewriter
<div id="main">
\family default
.
 It's got a funky class as well: 
\family typewriter
lift:surround?with=default;at=content
\family default
.
 This class invokes a snippet which surrounds the 
\family typewriter
<div>
\family default
 with the default template and inserts the 
\family typewriter
<div>
\family default
 and its children at the element with id 
\begin_inset Quotes eld
\end_inset

content
\begin_inset Quotes erd
\end_inset

 in the default template.
 Or, it wraps the default chrome around the 
\family typewriter
<div>
\family default
.
 For more on snippets, see 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Snippets"

\end_inset

.
\end_layout

\begin_layout Standard
Next, we define how we associate dynamic behavior with the list of chat
 elements: 
\family typewriter
<div class="lift:comet?type=Chat">
\family default
.
 The 
\begin_inset Quotes eld
\end_inset

comet
\begin_inset Quotes erd
\end_inset

 snippet looks for a class named 
\family typewriter
Chat
\family default
 that extends 
\family typewriter
CometActor
\family default
 and enables the mechanics of pushing content from the 
\family typewriter
CometActor
\family default
 to the browser when the state of the 
\family typewriter
CometActor
\family default
 changes.
 
\end_layout

\begin_layout Section
The Chat Comet component
\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "Actor Model"
target "http://en.wikipedia.org/wiki/Actor_model"

\end_inset

 provides state in functional languages include Erlang.
 Lift has an Actor library and LiftActors (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LiftActor"

\end_inset

) provides a powerful state and concurrency model.
 
\family typewriter
CometActors
\family default
 This may all seem abstract, so let's look at the 
\family typewriter
Chat
\family default
 class.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "chat/src/main/scala/code/comet/Chat.scala"
lstparams "caption={Chat.scala},label={Chat}"

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
Chat
\family default
 component has private state, registers with the 
\family typewriter
ChatServer
\family default
, handles incoming messages and can render itself.
 Let's look at each of those pieces.
\end_layout

\begin_layout Standard
The private state, like any private state in prototypical object oriented
 code, is the state that defines the object's behavior.
\end_layout

\begin_layout Standard
registerWith is a method that defines what component to register the Chat
 component with.
 Registration is a part of the Listener (or 
\begin_inset CommandInset href
LatexCommand href
name "Observer"
target "http://en.wikipedia.org/wiki/Observer_pattern"

\end_inset

) pattern.
 We'll look at the definition of the 
\family typewriter
ChatServer
\family default
 in a minute.
\end_layout

\begin_layout Standard
The 
\family typewriter
lowPriority
\family default
 method define how to process incoming messages.
 In this case, we're Pattern Matching (see 
\begin_inset CommandInset ref
LatexCommand prettyref
reference "sec:Pattern-Matching"

\end_inset

) the incoming message and if it's a 
\family typewriter
Vector[String]
\family default
, then we perform the action of setting our local state to the 
\family typewriter
Vector
\family default
 and re-rendering the component.
 The re-rendering will force the changes out to any browser that is displaying
 the component.
\end_layout

\begin_layout Standard
We define how to 
\family typewriter
render
\family default
 the component by defining the CSS to match and the replacement (See 
\begin_inset CommandInset ref
LatexCommand prettyref
reference "sec:CSS-Selector-Transforms"

\end_inset

).
 We match all the 
\family typewriter
<li>
\family default
 tags the the template and for each message, create an 
\family typewriter
<li>
\family default
 tag with the child nodes set to the message.
 Additionally, we clear all the elements that have the 
\family typewriter
clearable
\family default
 in the 
\family typewriter
class
\family default
 attribute.
\end_layout

\begin_layout Standard
That's it for the Chat CometActor component.
\end_layout

\begin_layout Section
The 
\family typewriter
ChatServer
\end_layout

\begin_layout Standard
The ChatServer code is:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "chat/src/main/scala/code/comet/ChatServer.scala"
lstparams "caption={ChatServer.scala},label={ChatServer.scala}"

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
ChatServer
\family default
 is defined as an 
\family typewriter
object
\family default
 rather than a 
\family typewriter
class
\family default
.
 This makes it a singleton which can be references by the name 
\family typewriter
ChatServer
\family default
 anywhere in the application.
 Scala's singletons differ from Java's 
\family typewriter
static
\family default
 in that the singleton is an instance of an object and that instance can
 be passed around like any other instance.
 This is why we can return the 
\family typewriter
ChatServer
\family default
 instance from the 
\family typewriter
registerWith
\family default
 method in that 
\family typewriter
Chat
\family default
 component.
\end_layout

\begin_layout Standard
The ChatServer has private state, a 
\family typewriter
Vector[String]
\family default
 representing the list of chat messages.
 Note that Scala's type inferencer infers the type of 
\family typewriter
msgs
\family default
 so you do not have the explicitly define it.
\end_layout

\begin_layout Standard
The 
\family typewriter
createUpdate
\family default
 method generates an update to send to listeners.
 This update is sent when a listener registers with the 
\family typewriter
ChatServer
\family default
 or when the 
\family typewriter
updateListeners()
\family default
 method is invoked.
\end_layout

\begin_layout Standard
Finally, the 
\family typewriter
lowPriority
\family default
 method defines the messages that this component can handle.
 If the 
\family typewriter
ChatServer
\family default
 receives a 
\family typewriter
String
\family default
 as a message, it appends the 
\family typewriter
String
\family default
 to the 
\family typewriter
Vector
\family default
 of messages and updates listeners.
\end_layout

\begin_layout Section
User Input
\end_layout

\begin_layout Standard
Let's go back to the view and see how the behavior is defined for adding
 lines to the chat.
\end_layout

\begin_layout Standard

\family typewriter
<form class="lift:form.ajax">
\family default
 defines an input form and the 
\family typewriter
form.ajax
\family default
 snippet turns a form into an Ajax (see 
\begin_inset CommandInset ref
LatexCommand prettyref
reference "sec:Ajax"

\end_inset

) form that will be submitted back to the server without cause a full page
 load.
\end_layout

\begin_layout Standard
Next, we define the input form element: 
\family typewriter
<input class="lift:ChatIn" id="chat_in"/>
\family default
.
 It's a plain old input form, but we've told Lift to modify the 
\family typewriter
<input>
\family default
's behavior by calling the 
\family typewriter
ChatIn
\family default
 snippet.
\end_layout

\begin_layout Section
Chat In
\end_layout

\begin_layout Standard
The 
\family typewriter
ChatIn
\family default
 snippet (See 
\begin_inset CommandInset ref
LatexCommand prettyref
reference "sec:Snippets"

\end_inset

) is defined as:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "chat/src/main/scala/code/snippet/ChatIn.scala"
lstparams "caption={ChatIn.scala},label={ChatIn.scala}"

\end_inset


\end_layout

\begin_layout Standard
The code is very simple.
 The snippet is defined as a method that associates a function with form
 element submission, 
\family typewriter
onSubmit
\family default
.
 When the element is submitted, be that normal form submission, Ajax, or
 whatever, the function is applied to the value of the form.
 In English, when the user submits the form, the function is called with
 the user's input.
\end_layout

\begin_layout Standard
The function sends the input as a message to the 
\family typewriter
ChatServer
\family default
 and returns JavaScript that sets the value of the input box to a blank
 string.
\end_layout

\begin_layout Section
Running it
\end_layout

\begin_layout Standard
Running the application is easy.
 Make sure you've got Java 1.6 or better installed on your machine.
 Change directories into the 
\family typewriter
chat
\family default
 directory and type 
\family typewriter
sbt update jetty-run
\family default
.
 The Simple Build Tool will download all necessary dependencies, compile
 the program and run it.
\end_layout

\begin_layout Standard
You can point a couple of browsers to 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://localhost:8080
\end_layout

\end_inset

 and start chatting.
\end_layout

\begin_layout Standard
Oh, and for fun, try entering 
\family typewriter
<script>alert('I ownz your browser');<script>
\family default
 and see what happens.
 You'll note it's what you want to happen.
\end_layout

\begin_layout Section
What you don't see
\end_layout

\begin_layout Standard
Excluding imports and comments, there are about 20 lines of Scala code to
 implement a multi-threaded, multi-user chat application.
 That's not a lot.
\end_layout

\begin_layout Standard
The first thing that's missing is synchronization or other explicit forms
 of thread locking.
 The application takes advantage of Actors and immutable data structures,
 thus the developer can focus on the business logic rather than the threading
 and locking primatives.
\end_layout

\begin_layout Standard
The next thing that's missing is routing and controllers and other stuff
 that you might have to do to wire up Ajax calls and polling for server-side
 changes (long or otherwise).
 In our application, we associated behavior with display and Lift took care
 of the rest (see 
\begin_inset CommandInset ref
LatexCommand prettyref
reference "sec:Page-rewriting"

\end_inset

).
\end_layout

\begin_layout Standard
We didn't do anything to explicitly to avoid cross-site scripting in our
 application.
 Because Lift takes advantage of Scala's strong typing and type safety (see
 
\begin_inset CommandInset ref
LatexCommand prettyref
reference "sec:Type-safety"

\end_inset

), Lift knows the difference between a String that must be HTML encoded
 and an HTML element that's already properly encoded.
 By default, Lift applications are resistant to many of the OWASP top 10
 security vulnerabilities (see 
\begin_inset CommandInset ref
LatexCommand prettyref
reference "sec:Security"

\end_inset

).
\end_layout

\begin_layout Standard
This example shows many of Lift's strengths.
 Let's expand the application and see how Lift's strengths continue to support
 the development of the application.
\end_layout

\begin_layout Chapter
Chat Plus
\end_layout

\begin_layout Chapter
Chat with Rooms
\end_layout

\begin_layout Chapter
Core Concepts
\end_layout

\begin_layout Section
Snippets
\begin_inset CommandInset label
LatexCommand label
name "sec:Snippets"

\end_inset


\end_layout

\begin_layout Standard
Lift is built on the Scala programming language.
 Scala is a hybrid of Functional and Object Oriented.
 Two core principles of functional programming languages are immutability
 and transformation.
\end_layout

\begin_layout Standard
Immutability means that once a data structure is instantiated, it will not
 change for its life.
 More concretely, once you instantiate an object, you can freely pass the
 object around and the object will always return the same values for all
 its methods.
 Java's 
\family typewriter
String
\family default
 class is immutable.
 Python requires immutable classes as indexes to dictionaries.
 Immutability is also very powerful for multithreaded applications because
 you can pass references to immutable objects across thread boundaries without
 having to worry about locking or synchronization because you are guaranteed
 that the objects will not change state.
\end_layout

\begin_layout Standard
Transformation 
\end_layout

\begin_layout Section
Box/Option
\begin_inset CommandInset label
LatexCommand label
name "sec:Box/Option"

\end_inset


\end_layout

\begin_layout Standard
Scala has a ton of nice features.
 One of the features that I was slow to adopt, until Burak Emir gently reminded
 me a bunch of times, is "Options".
 Read on about Options, Boxes, and how Lift makes good use of the to make
 clean, error resistant code.
 If you come from an imperative (Java, Ruby) background, you'll probably
 recognize the following code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x = someOperation 
\end_layout

\begin_layout Plain Layout

if !x.nil? 
\end_layout

\begin_layout Plain Layout

  y = someOtherOperation 
\end_layout

\begin_layout Plain Layout

  if !y.nil? 
\end_layout

\begin_layout Plain Layout

    doSomething(x,y) return "it worked" 
\end_layout

\begin_layout Plain Layout

  end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

return "it failed" 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Okay, so that's pseudo-code, but there are tons of operation, guard, operation,
 guard, blah blah constructs.
\end_layout

\begin_layout Standard
Further, null/nil are passed around as failures.
 This is especially bad when it's null, but it's pretty bad when it's nil
 because it's not clear to the consumer of the API that there can be a "call
 failed" return value.
\end_layout

\begin_layout Standard
In Java, null is a non-object.
 It has no methods.
 It is the exception to the statically typed rule (null has no class, but
 any reference of any class can be set to null.) Invoking a method on null
 has one and only one result: an exception is thrown.
 null is often returned from methods as a flag indicating that the method
 ran successfully, but yielded no meaningful value.
 For example, CardHolder.findByCreditCardNumber("2222222222") In fact, the
 guy who invented null called it a billion dollar mistake.
\end_layout

\begin_layout Standard
Ruby has nil which is marginally better than null.
 nil is a real, singleton object.
 There's only one instance of nil in the whole system.
 It has methods.
 It is a subclass of Object.
 Object has a method called "nil?" which returns false, except the nil singleton
 overrides this method to return true.
 nil is returned much like null in Java.
 It's the "no valid answer" answer.
\end_layout

\begin_layout Standard
Scala does something different.
\end_layout

\begin_layout Standard
There's an abstract class, called Option.
 Options are strongly typed.
 They are declared Option[T].
 This means an Option can be of any type, but once its type is defined,
 it does not change.
 There are two subclasses of Option: Some and None.
 None is a singleton (like nil).
 Some is a container around the actual answer.
 So, you might have a method that looks like:
\end_layout

\begin_layout Standard
def findUser(name: String): Option[User] = { val query = buildQuery(name)
 val resultSet = performQuery(query) val retVal = if (resultSet.next) Some(create
User(resultSet)) else None resultSet.close retVal } 
\end_layout

\begin_layout Standard
Some, you've got a findUser method that returns either Some(User) or None.
 So far, it doesn't look a lot different than our example above.
 So, to confuse everyone, I'm going to talk about collections for a minute.
\end_layout

\begin_layout Standard
A really nice thing in Scala (yes, Ruby has this too) is rich list operations.
 Rather than creating a counter and pulling list (array) elements out one
 by one, you write a little function and pass that function to the list.
 The list calls the function with each element and returns a new list with
 the values returned from each call.
 It's easier to see it in code:
\end_layout

\begin_layout Standard
scala> List(1,2,3).map(x => x * 2) line0: scala.List[scala.Int] = List(2,4,6)
\end_layout

\begin_layout Standard
The above code multiplies each list item by two and "map" returns the resulting
 list.
 Oh, and you can be more terse, if you want:
\end_layout

\begin_layout Standard
scala> List(1,2,3).map(_ * 2) line2: scala.List[scala.Int] = List(2,4,6)
\end_layout

\begin_layout Standard
You can nest map operations:
\end_layout

\begin_layout Standard
scala> List(1,2,3).map(x => List(4,5,6).map(y => x * y)) line13: scala.List[scala.Li
st[scala.Int]] = List(List(4,5,6),List(8,10,12),List(12,15,18))
\end_layout

\begin_layout Standard
And, you can "flatten" the inner list:
\end_layout

\begin_layout Standard
scala> List(1,2,3).flatMap(x => List(4,5,6).map(y => x * y)) line14: scala.List[sca
la.Int] = List(4,5,6,8,10,12,12,15,18)
\end_layout

\begin_layout Standard
Finally, you can "filter" only the even numbers from the first list:
\end_layout

\begin_layout Standard
scala> List(1,2,3).filter(_ % 2 == 0).
 flatMap(x => List(4,5,6).map(y => x * y)) line16: scala.List[scala.Int] =
 List(8,10,12)
\end_layout

\begin_layout Standard
But, as you can see, the map/flatMap/filter stuff gets pretty verbose.
 Scala introduced a "for" comprehension to make the code more readable:
\end_layout

\begin_layout Standard
scala> for {x <- List(1,2,3) if x % 2 == 0 y <- List(4,5,6)} yield x * y
 res0: List[Int] = List(8, 10, 12) 
\end_layout

\begin_layout Standard
Okay, but what does this have to do with Option[T]?
\end_layout

\begin_layout Standard
Turns out that Option implements map, flatMap, and filter (the methods necessary
 for the Scala compiler to use in the 'for' comprehension).
 Just as a side note, when I first encountered the phrase "'for' comprehension",
 I got scared.
 I've been doing programming for years and never heard of a "comprenhension"
 let alone a 'for' one.
 Turns out, that there's nothing fancy going on, but "'for' comprehension"
 is just a term of art for the above construct.
\end_layout

\begin_layout Standard
So, the cool thing is that you can use this construct very effectively.
 The first example is simple:
\end_layout

\begin_layout Standard
scala> for {x <- Some(3) y <- Some(4)} yield x * y res1: Option[Int] = Some(12)
 "That's nice, you just wrote a lot of code to multiply 3 by 4."
\end_layout

\begin_layout Standard
Let's see what happens if we have a "None" in there:
\end_layout

\begin_layout Standard
scala> val yOpt: Option[Int] = None yOpt: Option[Int] = None 
\end_layout

\begin_layout Standard
scala> for {x <- Some(3) y <- yOpt} yield x * y res3: Option[Int] = None
 So, we get a "None" back.
 How do we turn this into a default value?
\end_layout

\begin_layout Standard
scala> (for {x <- Some(3); y <- yOpt} yield x * y) getOrElse -1 res4: Int
 = -1 
\end_layout

\begin_layout Standard
scala> (for {x <- Some(3); y <- Some(4)} yield x * y) getOrElse -1 res5:
 Int = 12 Note that the "getOrElse" code is "passed by name".
 Put another way, that code is only executed if the "else" clause is valid.
\end_layout

\begin_layout Standard
Lift has an analogous construct called Box.
\end_layout

\begin_layout Standard
A Box Full or not.
 A non-Full Box can be the Empty singleton or a Failure.
 A Failure carries around information about why the Box contains no value.
\end_layout

\begin_layout Standard
Failure is very helpful because you can carry around information to display
 an error...
 an HTTP response code, a message, what have you.
\end_layout

\begin_layout Standard
In Lift, I put this all together in the following way:
\end_layout

\begin_layout Standard
methods that return request parameters return Box[String] finder methods
 on models (not find all, just the ones that return a single instance) return
 Box[Model] any method that would have returned a null if I was writing
 in Java returns a Box[T] in Lift That means you get code that looks like:
\end_layout

\begin_layout Standard
scala> for {id <- S.param("id") ?~ "id param missing" u <- getUser(id) ?~
 "User not found" } yield u.toXml res6: net.liftweb.common.Box[scala.xml.Elem]
 = Failure(id param missing,Empty,Empty) 
\end_layout

\begin_layout Standard
There's no explicit guard/test to see if the "id" parameter was passed in
 and there's no explicit test to see if the user was found.
\end_layout

\begin_layout Standard
Note also that this code is completely type-safe.
 While there was no explicit type declarations, the compiler was able to
 figure out what types the various objects were.
\end_layout

\begin_layout Standard
So, let's look at the code inside a REST handler:
\end_layout

\begin_layout Standard
serve { case "user" :: "info" :: _ XmlGet _ => for { id <- S.param("id")
 ?~ "id param missing" ~> 401 u <- User.find(id) ?~ "User not found" } yield
 u.toXml }
\end_layout

\begin_layout Standard
If the id parameter is missing, present a nice error message and return
 a 401 (okay...
 this is random, but you get the point).
 And by default, if the user isn't found, return a 404 with the error that
 the user isn't found.
\end_layout

\begin_layout Standard
Here's what it looks like using wget:
\end_layout

\begin_layout Standard
dpp@bison:~/lift_sbt_prototype$ wget http://localhost:8080/user/info.xml
 --2010-06-01 15:07:27-- http://localhost:8080/user/info.xml Resolving localhost...
 ::1, 127.0.0.1 Connecting to localhost|::1|:8080...
 connected.
 HTTP request sent, awaiting response...
 401 Unauthorized Authorization failed.
\end_layout

\begin_layout Standard
dpp@bison:~/lift_sbt_prototype$ wget http://localhost:8080/user/info.xml?id=2
 --2010-06-01 15:07:44-- http://localhost:8080/user/info.xml?id=2 Resolving
 localhost...
 ::1, 127.0.0.1 Connecting to localhost|::1|:8080...
 connected.
 HTTP request sent, awaiting response...
 404 Not Found 2010-06-01 15:07:44 ERROR 404: Not Found.
\end_layout

\begin_layout Standard
dpp@bison:~/lift_sbt_prototype$ wget http://localhost:8080/user/info.xml?id=1
 --2010-06-01 15:24:12-- http://localhost:8080/user/info.xml?id=1 Resolving
 localhost...
 ::1, 127.0.0.1 Connecting to localhost|::1|:8080...
 connected.
 HTTP request sent, awaiting response...
 200 OK Length: 274 [text/xml] Saving to: `info.xml?id=1'
\end_layout

\begin_layout Standard
dpp@bison:~/lift_sbt_prototype$ cat info.xml
\backslash
?id
\backslash
=1 <?xml version="1.0" encoding="UTF-8"?> <User id="1" firstName="Elwood"
 ...
 validated="true" superUser="false"></User> 
\end_layout

\begin_layout Standard
One more thing about Box and Option...
 they lead to less complex, more maintainable code.
 Even if you didn't know anything about Scala or Lift, you can read the
 XML serving code and the console exchange and figure out what happened
 any why it happened.
 This is a lot more readable than deeply nested if statements.
 And if it's readable, it's maintainable.
\end_layout

\begin_layout Standard
I hope this is an understandable introduction to Scala's Option class and
 'for' comprehension and how Lift makes use of these tools.
\end_layout

\begin_layout Section
S/SHtml
\begin_inset CommandInset label
LatexCommand label
name "sec:S/SHtml"

\end_inset


\end_layout

\begin_layout Section
GUIDs
\begin_inset CommandInset label
LatexCommand label
name "sec:GUIDs"

\end_inset


\end_layout

\begin_layout Section
LiftRules
\begin_inset CommandInset label
LatexCommand label
name "sec:LiftRules"

\end_inset


\end_layout

\begin_layout Section
SessionVars and RequestVars
\begin_inset CommandInset label
LatexCommand label
name "sec:SessionVars-and-RequestVars"

\end_inset


\end_layout

\begin_layout Section
Helpers
\begin_inset CommandInset label
LatexCommand label
name "sec:Helpers"

\end_inset


\end_layout

\begin_layout Section
CSS Selector Transforms
\begin_inset CommandInset label
LatexCommand label
name "sec:CSS-Selector-Transforms"

\end_inset


\end_layout

\begin_layout Standard
Lift 2.2-M1 introduced a new mechanism for transforming XHTML: CSS Selector
 Transforms (
\family typewriter
CssBindFunc
\family default
).
 The new mechanism provides a subset of CSS selectors that can be used to
 transform 
\family typewriter
NodeSeq => NodeSeq
\family default
.
 Examples of this feature include:
\end_layout

\begin_layout Itemize

\family typewriter
"#name" #> userName
\family default
 // replace the element with the id name with the variable userName 
\end_layout

\begin_layout Itemize

\family typewriter
"#chat_lines *" #> listOfChats
\family default
 // replace the content of chat_lines with each element of listOfChats 
\end_layout

\begin_layout Itemize

\family typewriter
".pretty *" #> <b>Unicorn</b>
\family default
 // each element with CSS class pretty, replace content with <b>Unicorn</b>
\end_layout

\begin_layout Itemize

\family typewriter
"dog=cat [href]" #> "http://dogscape.com"
\family default
 // set the href attribute of all elements with the dog attribute set to
 cat 
\end_layout

\begin_layout Itemize

\family typewriter
"#name" #> userName & "#age" #> userAge
\family default
 // set name to userName and age to userAge
\end_layout

\begin_layout Itemize

\family typewriter
"li *" #> userName & "li [class]" #> "foo"
\family default
 // set the contents of all <li> element with username and class to foo
\end_layout

\begin_layout Itemize

\family typewriter
"li *" #> userName & "li [class+]" #> "foo"
\family default
 // set the contents of all <li> element with username and append foo to
 the class
\end_layout

\begin_layout Itemize

\family typewriter
"*" #> <span>{userName}</span>
\family default
 // set all the elements to <span>{userName}</span>
\end_layout

\begin_layout Standard
CSS Selector Transforms extends 
\family typewriter
NodeSeq => NodeSeq
\family default
...
 they are quite literally functions and can be passes as a parameter to
 anything expecting 
\family typewriter
NodeSeq => NodeSeq
\family default
 or returned as a result for any method that returns 
\family typewriter
NodeSeq => NodeSeq
\family default
.
\end_layout

\begin_layout Standard
Let's look at each of the pieces to see how they work.
\end_layout

\begin_layout Standard
First, you must 
\family typewriter
import net.liftweb.util._
\family default
 and 
\family typewriter
import Helpers._
\family default
 These packages include the classes and the implicit conversions that make
 the CSS Selector Tranforms work.
\end_layout

\begin_layout Standard
The transform is defined by: String representing selector #> transform value.
\end_layout

\begin_layout Standard
The selector is a String constant which implements the following subset
 of CSS Selectors:
\end_layout

\begin_layout Itemize

\family typewriter
#id
\family default
 - selects the element with the specified id 
\end_layout

\begin_layout Itemize

\family typewriter
.class
\family default
 - selects all elements have a class attribute where one of the space-separated
 values equals class 
\end_layout

\begin_layout Itemize

\family typewriter
attr_name=attr_value
\family default
 - selects all elements where the given attribute equals the given value
\end_layout

\begin_layout Itemize

\family typewriter
element_name
\family default
 - selects all the elements matching the name
\end_layout

\begin_layout Itemize

\family typewriter
*
\family default
 - selects all elements
\end_layout

\begin_layout Standard
You can put replacement rules after the selector:
\end_layout

\begin_layout Itemize
none (e.g., 
\family typewriter
"#id"
\family default
) replaces all matching elements with the values
\begin_inset Newline newline
\end_inset


\family typewriter
"#name" #> "David" // <span><span id="name"/></span> -> <span>David</span>
\end_layout

\begin_layout Itemize

\family typewriter
*
\family default
 (e.g., "
\family typewriter
#id *
\family default
") replaces the content children of the matching elements with the values
\begin_inset Newline newline
\end_inset


\family typewriter
"#name *" #> "David" // <span><span id="name"/></span> -> <span><span id="name>D
avid</span></span>
\end_layout

\begin_layout Itemize

\family typewriter
[attr]
\family default
 (e.g., "#id 
\family typewriter
[href]
\family default
") replaces the matching attribute's value with the values.
 
\begin_inset Newline newline
\end_inset


\family typewriter
"#link [href]" #> "http://dogscape.com" 
\begin_inset Newline newline
\end_inset

// <a href="#" id="link">Dogscape</a> -> <a href="http://dogscape.com" id="link">
Dogscape</a>
\end_layout

\begin_layout Itemize

\family typewriter
[attr+]
\family default
 (e.g., "#id 
\family typewriter
[class+]
\family default
") appends the value to the existing attribute.
\begin_inset Newline newline
\end_inset


\family typewriter
"span [class+]" #> "error" 
\begin_inset Newline newline
\end_inset

// <span class"foo">Dogscape</span> -> <span class"foo error">Dogscape</span>
\end_layout

\begin_layout Standard
The right hand side of the CSS Selector Transform can be one of the following:
\end_layout

\begin_layout Itemize

\family typewriter
String
\family default
 -- a 
\family typewriter
String
\family default
 constant, for example: 
\begin_inset Newline newline
\end_inset

"#name *" #> "David" // <span id="name"/> -> <span id="name">David</span>
 
\begin_inset Newline newline
\end_inset

"#name *" #> getUserNameAsString
\end_layout

\begin_layout Itemize

\family typewriter
NodeSeq
\family default
 - a 
\family typewriter
NodeSeq
\family default
 constant, for example:
\begin_inset Newline newline
\end_inset

"#name *" #> <i>David</i> // <span id="name"/> -> <span id="name"><i>David</i></
span>
\begin_inset Newline newline
\end_inset

"#name *" #> getUserNameAsHtml
\end_layout

\begin_layout Itemize
NodeSeq => NodeSeq -- a function that transforms the node (yes, it can be
 a CssBindFunc):
\begin_inset Newline newline
\end_inset

"#name" #> (n: NodeSeq) => n % ("class" -> "dog") // <span id="name"/> ->
 <span id="name" class="dog"/>
\end_layout

\begin_layout Itemize
Bindable -- something that implements the Bindable trait (e.g., MappedField
 and Record.Field)
\end_layout

\begin_layout Itemize
StringPromotable -- A constant that can be promoted to a String (Int, Symbol,
 Long or Boolean).
 There is an automatic (implicit) conversion from Int, Symbol, Long or Boolean
 to StringPromotable.
\begin_inset Newline newline
\end_inset

"#id_like_cats" #> true "#number_of_cats" #> 2
\end_layout

\begin_layout Itemize
IterableConst -- A Box, Seq, or Option of String, NodeSeq, or Bindable.
 Implicit conversions automatically promote the likes of Box[String], List[Strin
g], List[NodeSeq], etc.
 to IterableConst.
\begin_inset Newline newline
\end_inset

"#id" #> (Empty: Box[String]) // <span><span id="id">Hi</span></span> ->
 <span/>
\begin_inset Newline newline
\end_inset

"#id" #> List("a", "b", "c") // <span><span id="id"/></span> -> <span>abc</span>
\begin_inset Newline newline
\end_inset

"#id [href]" #> (None: Option[String]) <a id="id" href="dog"/> -> <a id="id"/>
\end_layout

\begin_layout Itemize
List[NodeSeq => NodeSeq], Box[NodeSeq => NodeSeq], Option[NodeSeq => NodeSeq]
 - 
\end_layout

\begin_layout Standard
Note that if you bind to the children of a selected element, multiple copies
 of the element result from bind to an IterableConst (if the element has
 an id attribute, the id attribute will be stripped after the first element):
 "#line *" #> List("a", "b", "c") // <li id="line>sample</li> -> <li id="line">a
</li><li>b</li><li>c</li> "#age *" #> (None: Option[NodeSeq]) // <span><span
 id="age">Dunno</span></span> -> <span/>
\end_layout

\begin_layout Standard
The above use cases may seem a little strange (they are not quite orthogonal),
 but they address common use cases in Lift.
 * IterableFunc -- A Box, Seq, or Option of functions that transform NodeSeq
 => String, NodeSeq, Seq[String], Seq[NodeSeq], Box[String], Box[NodeSeq],
 Option[String] or Option[NodeSeq].
 The same rules for handling multiple values in IterableConst apply to IterableF
unc.
 Implicit conversions automatically promote the functions with the appropriate
 signature to an IterableFunc.
\end_layout

\begin_layout Standard
You can chain CSS Selector Transforms with the 
\family typewriter
&
\family default
 method:
\begin_inset Newline newline
\end_inset


\family typewriter
"#id" #> "33" & "#name" #> "David" & "#chat_line" #> List("a", "b", "c")
 & ClearClearable
\end_layout

\begin_layout Standard
CSS Selector Transforms offer an alternative to Lift's traditional binding
 (See Helpers.bind()).
\end_layout

\begin_layout Section
Client-side behavior invoking server-side functions
\begin_inset CommandInset label
LatexCommand label
name "sec:Client-side-behavior-invoking"

\end_inset


\end_layout

\begin_layout Section
Ajax
\begin_inset CommandInset label
LatexCommand label
name "sec:Ajax"

\end_inset


\end_layout

\begin_layout Section
Comet
\begin_inset CommandInset label
LatexCommand label
name "sec:Comet"

\end_inset


\end_layout

\begin_layout Section
LiftActor
\begin_inset CommandInset label
LatexCommand label
name "sec:LiftActor"

\end_inset


\end_layout

\begin_layout Section
Pattern Matching
\begin_inset CommandInset label
LatexCommand label
name "sec:Pattern-Matching"

\end_inset


\end_layout

\begin_layout Section
Type safety
\begin_inset CommandInset label
LatexCommand label
name "sec:Type-safety"

\end_inset


\end_layout

\begin_layout Section
Page rewriting
\begin_inset CommandInset label
LatexCommand label
name "sec:Page-rewriting"

\end_inset


\end_layout

\begin_layout Section
Security
\begin_inset CommandInset label
LatexCommand label
name "sec:Security"

\end_inset


\end_layout

\begin_layout Chapter
Common Patterns
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "localization.lyx"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Dependency Injection
\end_layout

\begin_layout Standard
Lift and Dependency Injection Dependency injection is an important topic
 in the Java world.
 It's important because Java lacks certain basic features (e.g., functions)
 that tend to bind abstract interfaces to concrete implementations.
 Basically, it's so much easier to do MyInterface thing = new MyInterfaceImpl(),
 so most developers do just that.
 Scala's cake pattern goes a long way to help developers compose complex
 behaviors by combining Scala traits.
 Jonas BonÃ©r wrote an excellent piece on Dependency Injection.
 The cake pattern only goes half way to giving a Java developer complete
 dependency injection functionality.
 The cake pattern allows you to compose the complex classes out of Scala
 traits, but the cake pattern is less helpful in terms of allowing you to
 make dynamic choices about which combination of cake to vend in a given
 situation.
 Lift provides a extra features that complete the dependency injection puzzle.
 Lift Libraries and Injector Lift is both a web framework and a set of Scala
 libraries.
 Lift's common, actor, json, and util packages provide common libraries
 for Scala developers to build their application.
 Lift's libraries are well tested, widely used, well supported, and released
 on a well defined schedule (montly milestones, quarterly releases).
 Lift's Injector trait forms the basis of dependency injection: /** * A
 trait that does basic dependency injection.
 */trait Injector { implicit def inject[T](implicit man: Manifest[T]): Box[T]}
 You can use this trait as follows: object MyInjector extends Injector {...}val
 myThing: Box[Thing] = MyInjector.inject The reason that the instance of
 MyThing is in a Box is because we're not guaranteed that MyInjector knows
 how to create an instance of Thing.
 Lift provides an implementation of Injector called SimpleInjector that
 allows you to register (and re-register) functions for injection:
\end_layout

\begin_layout Standard
object MyInjector extends SimpleInjectordef buildOne(): Thing = if (testMode)
 new Thing with TestThingy {} else new Thing with RuntimeThingy {}MyInjector.regi
sterInjection(buildOne _) // register the function that builds Thing val
 myThing: Box[Thing] = MyInjector.inject This isn't bad...
 it allows us to define a function that makes the injection-time decision,
 and we can change the function out during runtime (or test-time.) However,
 there are two problems: getting Boxes for each injection is less than optimal.
 Further, globally scoped functions mean you have to put a whole bunch of
 logic (test vs.
 production vs.
 xxx) into the function.
 SimpleInjector has lots of ways to help out.
\end_layout

\begin_layout Standard
object MyInjector extends SimpleInjector { val thing = new Inject(buildOne
 _) {} // define a thing, has to be a val so it's eagerly evaluated and
 registered}def buildOne(): Thing = if (testMode) new Thing with TestThingy
 {} else new Thing with RuntimeThingy {} val myThingBox: Box[Thing] = MyInjector.
injectval myThing = MyInjector.thing.vend // vend an instance of Thing Inject
 has a futher trick up its sleave...
 with Inject, you can scope the function...
 this is helpful for testing and if you need to change behavior for a particular
 call scope:
\end_layout

\begin_layout Standard
MyInjector.thing.doWith(new Thing with SpecialThing {}) { val t = MyInjector.thing.v
end // an instance of SpecialThing val bt: Box[Thing] = MyInjector.inject
 // Full(SpecialThing) }MyInjector.thing.default.set(() => new Thing with YetAnothe
rThing {}) // set the global scope Within the scope of the doWith call,
 MyInjector.thing will vend instances of SpecialThing.
 This is useful for testing as well as changing behavior within the scope
 of the call or globally.
 This gives us much of the functionality we get with dependency injection
 packages for Java.
 But within Lift WebKit, it gets better.
\end_layout

\begin_layout Standard
Lift WebKit and enhanced injection scoping Lift's WebKit offers broad ranging
 tools for handling HTTP requests as well as HTML manipulation.
\end_layout

\begin_layout Standard
Lift WebKit's Factory extends SimpleInjector, but adds the ability to scope
 the function based on current HTTP request or the current container session:
\end_layout

\begin_layout Standard
object MyInjector extends Factory { val thing = new FactoryMaker(buildOne
 _) {} // define a thing, has to be a val so it's eagerly evaluated and
 registered} MyInjector.thing.session.set(new Thing with ThingForSession {})
 // set the instance that will be vended for the duration of the session
 MyInjector.thing.request.set(new Thing with ThingForRequest {}) // set the
 instance that will be vended for the duration of the request WebKit's LiftRules
 is a Factory and many of the properties that LiftRules contains are FactoryMake
rs.
 This means that you can change behavior during call scope (useful for testing):
\end_layout

\begin_layout Standard
LiftRules.convertToEntity.doWith(true) { ...
 test that we convert certain characters to entities} Or based on the current
 request (for example you can change the rules for calculating the docType
 during the current request):
\end_layout

\begin_layout Standard
if (isMobileReqest) LiftRules.docType.request.set((r: Req) => Full(DocType.xhtmlMobi
le)) Or based on the current session (for example, changing maxConcurrentRequest
s based on some rules when a session is created): if (browserIsSomethingElse)
 LiftRules.maxConcurrentRequests.session.set((r: Req) => 32) // for this session,
 we allow 32 concurrent requests Conclusion Lift's SimpleInjector/Factory
 facilities provide a powerful and flexible mechanism for vending instances
 based on a global function, call stack scoping, request and session scoping
 and provides more flexible features than most Java-based dependency injection
 frameworks without resorting to XML for configuration or byte-code rewriting
 magic.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "htmlproperties.lyx"

\end_inset


\end_layout

\begin_layout Chapter
Built-in Snippets
\end_layout

\begin_layout Section
CSS
\begin_inset CommandInset label
LatexCommand label
name "sec:CSS"

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Msgs"

\end_inset

Msgs
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Msg"

\end_inset

Msg
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Menu"

\end_inset

Menu
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:A"

\end_inset

A
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Children"

\end_inset

Children
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:CometSnippet"

\end_inset

Comet
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Form"

\end_inset

Form
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Ignore"

\end_inset

Ignore
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Loc"

\end_inset

Loc
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Surround"

\end_inset

Surround
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:TestCond"

\end_inset

TestCond
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Embed"

\end_inset

Embed
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Tail"

\end_inset

Tail
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:WithParam"

\end_inset

WithParam
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:VersionInfo"

\end_inset

VersionInfo
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:SkipDocType"

\end_inset

SkipDocType
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:XmlGroup"

\end_inset

XmlGroup
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:LazyLoad"

\end_inset

LazyLoad
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:WithResourceId"

\end_inset

WithResourceId
\end_layout

\begin_layout Chapter
SiteMap
\end_layout

\begin_layout Chapter
REST
\end_layout

\begin_layout Chapter
MVC (If you really want it)
\end_layout

\begin_layout Part
Recipes
\end_layout

\begin_layout Part
Questions and Answers
\end_layout

\begin_layout Chapter
Scaling
\end_layout

\begin_layout Standard
Lift is a web framework built on the Scala programming language.
 Lift takes advantage of many of Scala's features that allows developers
 to very concisely code secure, scalable, highly interactive web applications.
 Lift provides a full set of layered abstractions on top of HTTP and HTML
 from "close to the metal" REST abstractions up to transportation agnostic
 server push (Comet) support.
 Scala compiles to JVM byte-code and is compatible with Java libraries and
 the Java object model.
 Lift applications are typically deployed as WAR files in J/EE web containers...
 Lift apps run in Tomcat, Jetty, Glassfish, etc.
 just like any other J/EE web applications.
 Lift apps can generally be monitored and managed just like any Java web
 app.
 Web Applications, Sessions, and State All web applications are stateful
 in one way or another.
 Even a "static" web site is made up of the files that are served...
 the application's state is defined in those files.
 The site content may be served out of a database, but the content served
 does not depend on identity of the user or anything about the HTTP request
 except the contents of the HTTP request.
 These contents can include the URI, parameters, and headers.
 The complete value of the response can be calculated from the request without
 referencing any resources except the content resources.
 For the purpose of this discussion, I will refer to these as session-less
 requests.
 News sites like the UK Guardian, MSNBC, and others are prototypical examples
 of this kind of site.
 Sessions Some applications are customized on a user-by-user basis.
 These applications include the likes of Foursquare and others where many
 HTTP requests make up a "session" in which the results of previous HTTP
 requests change the behavior of future HTTP requests.
 Put in concrete terms, a user can log into a site and for some duration,
 the responses are specific to that user.
 There are many mechanisms for managing sessions, but the most common and
 secure method is creating a cryptographically unique token (a session id),
 and putting that token in the Set-Cookie response header such that the
 browser will present that Cookie in subsequent HTTP requests for a certain
 period of time.
 The server-side state is referenced by the Cookie and the state is made
 available to the web application during the scope of servicing the request
 and any mutations the web app makes to session state during the request
 are kept on the server and are available to the application in subsequent
 requests.
 Another available technique for managing state is to serialize application
 state in the Cookie and deliver it to the browser such that the server
 is not responsible for managing state across requests.
 As we've recently discovered, this is a tremendously insecure way to manage
 application state.
 Further, for any moderately complex application, the amount of data the
 needs to be transferred as part of each request and response is huge.
 Migratory Sessions Many web application managers allow for server-managed
 sessions to migrate across a cluster of web application servers.
 In some environments such as Ruby on Rails, this is a hard requirement
 because only one request at a time can be served per process, thus for
 any moderate traffic site, there must be multiple processes serving pages.
 There are many strategies for migrating state across processes: storing
 state on disk, in memcached, in a database (relational or NoSQL), or having
 some proprietary cluster communications protocol.
 In any of these scenarios sessions can migrate across the grid of processes
 serving requests for a given web application.
 Web applications that support migratory state are often referred to as
 "stateless" because the session state does not reside in the same process
 as the web application.
 Session Affinity Some applications require that all requests related to
 a particular session are routed to the same process and that process keeps
 session-related content in local memory.
 In a cluster, there are multiple mechanisms for achieving session affinity...
 the two most popular being HAProxy and Nginx.
 Availability, Scalability, Security, Performance, and User Experience There
 are many vectors on which to measure the over-quality of a web applications.
 Let's take a quick peek at each one.
 Availability Availability of an application is the amount of time it gives
 a meaningful response to a request.
 Highly available applications generally span multiple pieces of hardware
 and often multiple data centers.
 Highly available applications are also typically available during upgrades
 of part of the system that makes up the application.
 Highly available applications have very few single points of failure and
 those single points of failure are usually deployed on very reliable hardware.
 Scalability A scalable application can, within certain bounds, respond
 with similar performance to increased load by adding hardware to process
 more load.
 No system is infinitely or linearly scalable.
 However, many systems have grossly disproportionate load demands such that,
 for example, you can add a lot of web application front-ends to a Rails
 application before there's enough load on the back-end RDBMS such that
 scaling is impaired.
\end_layout

\begin_layout Standard
Security The Internet is a dangerous place and no request that is received
 from the Internet can be trusted.
 Applications, frameworks, systems and everything else must be designed
 to be secure and resist attacks.
 The most common attacks on web application are listed in the OWASP Top
 Ten.
 Performance Web application performance can be measured on two vectors:
 response time to a request and system resources required to service the
 request.
 These two vectors are inter-dependent User Experience The user experience
 of a web app is an important measure of its quality.
 User experience can be measured on many different vectors including perceived
 responsiveness, visual design, interactivity, lack of "hicups", etc.
 Ultimately, because we're building applications for users, the user experience
 is very important.
 Lift's trade-offs Given the number and complexity related to the quality
 of a web application, there are a lot of trade-offs, implicit and explicit,
 to building a framework that allows developers and business people to deliver
 a great user experience.
 Let's talk for a minute about what Lift is and what it isn't.
 Lift is a web framework.
 It provides a set of abstractions over HTTP and HTML such that developers
 can write excellent web applications.
 Lift is persistence agnostic.
 You can use Lift with relational databases, file systems, NoSQL data stores,
 mule carts, etc.
 As long as you can materialize an object into the JVM where Lift is running,
 Lift can make use of that object.
 Lift sits on top of the JVM Lift applications execute in the Java Virtual
 Machine.
 The JVM is a very high performance computing system.
 There are raging debates as to the relative performance of JVM code and
 native machine code.
 No matter which benchmarks you look at, the JVM is a very fast performer.
 Lift apps take advantage of the JVM's performance characteristics.
 Moderately complex Lift apps that access the database can serve 1,000+
 requests per second on quad-core Intel hardware.
 Even very complex Lift apps that make many back-end calls per request can
 serve hundreds of requests per second on EC2 large instances.
 Lift as proxy Many web applications, typically REST applications, provide
 a very thin layer on top of a backing data store.
 The web application serves a few basic functions to broker between the
 HTTP request and the backing store.
 These functions include: request and parameter validation, authentication,
 parameter unpacking, back-end service request, and translation of response
 data to wire format (typically XML or JSON).
 Lift can service these kinds of requests within the scope of a session
 or without any session at all, depending on application design.
 For more information on Lift's REST features, see Lift RestHelper.
 When running these kinds of services, Lift apps can be treated without
 regard for session affinity.
 Lift as HTML generator Lift has a power and secure templating mechanism.
 All Lift templates are expressed as valid XML and during the rendering
 process, Lift keeps the page in XML format.
 Pages rendered via Lift's templating mechanism are generally resistant
 to cross site scripting attacks and other attacks that insert malicious
 content in rendered pages.
 Lift's templating mechanism is designer friendly yet support complex and
 powerful substitution rules.
 Further, the rendered page can be evaluated and transformed during the
 final rendering phase to ensure that all script tags are at the bottom
 of the page, all CSS tags are at the top, etc.
 Lift's templating mechanism can be used to serve sessionless requests or
 serve requests within the context of a session.
 Further, pages can be marked as not requiring a session, yet will make
 session state available is the request was made in the context of a container
 session.
 Lift page rendering can even be done in parallel such that if there are
 long off-process components on the page (e.g., advertising servers), those
 components can be Sessionless Lift, forms and Ajax Lift applications can
 process HTML forms and process Ajax requests even if there's no session
 associated with the request.
 Such forms and Ajax requests have to have stable field names and stable
 URLs, but this is the same requirement as most web frameworks including
 Struts, Rails, and Django impose on their applications.
 In such a mode, Lift apps have the similar characteristics to web apps
 written on tops of Struts, Play, JSF and other popular Java web frameworks.
 Lift as Secure, Interactive App Platform Lift features require session
 affinity: GUID to function mapping, type-safe SessionVars and Comet.
 Applications that take advantage of these features need to have requests
 associated with the JVM that stores the session.
 I'll discuss the reason for this limitation, the down-side to the limitation,
 the downside to migratory session, and the benefits of these features.
 Application servers that support migratory sessions (sessions that are
 available to application servers running in multiple address spaces/processes)
 require a mechanism for transferring the state information between processes.
 This is typically (with the exception of Terracotta) done by serializing
 the stored data.
 Serialization is the process of converting rich data structures into a
 stream of bytes.
 Some of Scala's constructs are hard or impossible to serialize.
 For example, local variables that are mutated within a closure are promoted
 from stack variables to heap variables.
 When those variables are serialized at different times, the application
 winds up with two references even though the references are logically the
 same.
 Lift makes use of many of these constructs (I'll explain why next) and
 Lift's use of these constructs makes session serialization and migration
 impossible.
 It also means that Lift's type-safe SessionVars are not guaranteed to be
 serialized.
 One of the key Lift constructs is to map a cryptographically unique identifier
 in the browser to a function on the server.
 Lift uses Scala functions which close over scope, including all of the
 variables referenced by the function.
 This means that it's not necessary to expose primary keys to the client
 when editing a record in the database because the primary key of the record
 or the record itself is known to the function on the server.
 This guards against OWASP Vulnerability A4, Insecure Object References
 as well as Replay Attacks.
 From the developer's standpoint, writing Lift applications is like writing
 a VisualBasic application...
 the developer associates the user action with a function.
 Lift supplies the plumbing to bridge between the two.
 Lift's GUID to function mapping extends to Lift's Ajax support.
 Associating a button, checkbox, or other HTML element with an Ajax call
 is literally a single line: SHtml.ajaxButton(<b>PressMe</b>, () => Alert("You
 pressed a button at "+Helpers.currentTimeFormatted) Lift's Ajax support
 is simple, maintainable, and secure.
 There's no need to build and maintain routing.
 Lift has the most advanced server-push/Comet support of any web framework
 or any other system currently available.
 Lift's comet support relies on session affinity.
 Lift's comet support associates an Actor with a section of screen real
 estate.
 A single browser window may have many pieces of screen real estate associated
 with many of Lift's CometActors.
 When state changes in the Actor, the state change is pushed to the browser.
 Lift takes care of multiplexing a single HTTP connection to handle all
 the comet items on a given page, the versioning of the change deltas (if
 the HTTP connection is dropped while 3 changes become available, all 3
 of those changes are pushed when the next HTTP request is made.) Further,
 Lift's comet support will work the same way once web sockets are available
 to the client and server...
 there will be no application code changes necessary for web sockets support.
 Lift's comet support requires that the connect is made from the browser
 back to the same JVM in which the CometActors are resident...
 the same JVM where the session is located.
\end_layout

\begin_layout Standard
The downside to Lift's session affinity requirement mainly falls on the
 operations team.
 They must use a session aware load balancer or other mechanism to route
 incoming requests to the server that the session is associated with.
 This is easily accomplished with HAProxy and Nginx.
 Further, if the server running a given session goes down, the information
 associated with that session is lost (note that any information distributed
 off-session [into a database, into a cluster of Akka actors, etc.] is preserved.)
 But, Lift has extended session facilities that support re-creation of session
 information in the event of session lost.
 Lift also has heart-beat functionality so that sessions are kept alive
 as long as a browser page is open to the application, so user inactivity
 will not result in session timeouts.
\end_layout

\begin_layout Standard
Compared to the operational cost of a session aware load balancer, there
 are many costs associated with migratory sessions.
 First, there must be a persistence mechanism for those sessions.
 Memcached is an unreliable mechanism as memcached instances have no more
 stability than the JVM which hosts the application and being a cache, some
 sessions may get expired.
 Putting session data in backing store such as MySQL or Cassandra increases
 the latency of requests.
 Further, the costs of serializing state, transmitting the state across
 the network, storing it, retrieving it, transmitting it across the network,
 and deserializing it all costs a lot of cycles and bandwidth.
 When your Lift application scales beyond a single server, beyond 100 requests
 per second, the costs of migrating state on every request becomes a significant
 operational issue.
\end_layout

\begin_layout Standard
Session serialization can cause session information loss in the case of
 multiple requests being executed in multiple processes.
 It's common to have multiple tabs/windows open to the same application.
 If session data is serialized as a blob and two different requests from
 the same server are being executed at the same time, the last request to
 write session data into the store will over-write the prior session data.
 This is a concurrency problem and can lead to hard to debug issues in productio
n because reproducing this kind of problem is non-trivial and this kind
 of problem is not expected by developers.
\end_layout

\begin_layout Standard
The third issue with migratory sessions and session serialization is that
 the inability to store complex information in the session (e.g., a function
 that closes over scope) means that the developer has to write imperative
 code to serialize session state to implement complex user interactions
 like multi-screen wizards (which is a 400 line implementation in Lift).
 These complex, hand written serializations are error prone, can introduce
 security problems and are non-trivial to maintain.
\end_layout

\begin_layout Standard
The operational costs of supporting session affinity are not materially
 different from the operational costs of providing backing store for migratory
 sessions.
 On the other hand, there are many significant downsides to migratory sessions.
 Let's explore the advantages of Lift's design.
\end_layout

\begin_layout Standard
Lift's use of GUIDs associated with functions on the server: Increase the
 security of the application by guarding against cross site request forgeries,
 replay attacks, and insecure object references Decrease application development
 and maintenance time and costs Increase application interactivity, thus
 a much better user experience Increase in application richness because
 of simpler Ajax, multi-page Wizards, and Comet Improved application performance
 because fewer cycles are spent serializing and transmitting session information
 No difference in scalability...
 just add more servers to the front end to scale the front end of your applicati
on The positive attributes of Lift's design decisions are evident at Foursquare
 which handles thousands of requests per second all served by Lift.
 There are very few sites that have more traffic than Foursquare.
 They have scaled their web front end successfully and securely with Lift.
 Other high volume sites including Novell are successfully scaling with
 Lift.
 If you are scaling your site, there are also commercial Lift Cloud manager
 tools that can help manage clusters of Lift's session requirements.
 Conclusion Lift provides a lot of choices for developing and deploying
 complex web applications.
 Lift can operate in a web container like any other Java web framework.
 If you choose to use certain Lift features and you are deploying across
 multiple servers, you need to have a session aware load balancer.
 Even when using Lift's session-affinity dependent features, Lift applications
 have higher performance, identical availability, identical scalability,
 better security, and better user experience than applications written with
 web frameworks such as Ruby on Rails, Struts, and GWT.
\end_layout

\begin_layout Chapter
How Lift does function/GUID mapping
\end_layout

\begin_layout Chapter
How Lift does Comet
\end_layout

\begin_layout Standard
I can speak to Lift's Comet Architecture which was selected by Novell to
 power their Pulse product after they evaluated a number of different technologi
es.
\end_layout

\begin_layout Standard
Lift's Comet implementation uses a single HTTP connection to poll for changes
 to an arbitrary number of components on the page.
 Each component has a version number.
 The long poll includes the version number and the component GUID.
 On the server side, a listener is attached to all of the GUIDs listed in
 the long poll requests.
 If any of the components has a higher version number (or the version number
 increases during the period of the long poll), the deltas (a set of JavaScript
 describing the change from each version) is sent to the client.
 The deltas are applied and the version number on the client is set to the
 highest version number for the change set.
\end_layout

\begin_layout Standard
Lift integrates long polling with session management so that if a second
 request comes into the same URL during a long poll, the long poll is terminated
 to avoid connection starvation (most browsers have a maximum of 2 HTTP
 connections per named server).
 Lift also supports DNS wild-carded servers for long poll requests such
 that each tab in the browser can do long polling against a different DNS
 wildcarded server.
 This avoids the connection starvation issues.
\end_layout

\begin_layout Standard
Lift dynamically detects the container the Servlet is running in and on
 Jetty 6 & 7 and (soon) Glassfish, Lift will use the platform's "continuations"
 implementation to avoid using a thread during the long poll.
\end_layout

\begin_layout Standard
Lift's JavaScript can sit on top of jQuery and YUI (and could sit on top
 of Prototype/Scriptaculous as well.) The actual polling code includes back-off
 on connection failures and other "graceful" ways of dealing with transient
 connection failures.
\end_layout

\begin_layout Standard
I've looked at Atmosphere and CometD (both JVM-oriented Comet technologies).
 Neither had (at the time I evaluated them) support for multiple components
 per page or connection starvation avoidance.
\end_layout

\end_body
\end_document
